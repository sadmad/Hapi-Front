import{stringify as J}from"query-string";import{stringify as y}from"query-string";var M=r=>{switch(r){case"ne":case"gte":case"lte":return`_${r}`;case"contains":return"_like";default:return""}};var f=r=>{if(r&&r.length>0){let s=[],e=[];return r.map(t=>{s.push(t.field),e.push(t.order)}),{_sort:s,_order:e}}};var g=r=>{let s={};return r&&r.map(e=>{if(e.operator==="or"||e.operator==="and")throw new Error(`[@refinedev/simple-rest]: \`operator: ${e.operator}\` is not supported. You can create custom data provider. https://refine.dev/docs/api-reference/core/providers/data-provider/#creating-a-data-provider`);if("field"in e){let{field:t,operator:o,value:n}=e;if(t==="q"){s[t]=n;return}let d=M(o);s[`${t}${d}`]=n}}),s};import j from"axios";var h=j.create();h.interceptors.response.use(r=>r,r=>{var e,t,o;let s={...r,message:(t=(e=r.response)==null?void 0:e.data)==null?void 0:t.message,statusCode:(o=r.response)==null?void 0:o.status};return Promise.reject(s)});var q=(r,s=h)=>({getList:async({resource:e,pagination:t,filters:o,sorters:n,meta:d})=>{let i=`${r}/${e}`,{current:c=1,pageSize:a=10,mode:p="server"}=t??{},{headers:$,method:m}=d??{},x=m??"get",v=g(o),u={};p==="server"&&(u._start=(c-1)*a,u._end=c*a);let l=f(n);if(l){let{_sort:T,_order:b}=l;u._sort=T.join(","),u._order=b.join(",")}let _={...u,...v},O=Object.keys(_).length?`${i}?${y(_)}`:i,{data:w,headers:F}=await s[x](O,{headers:$}),S=+F["x-total-count"];return{data:w,total:S||w.length}},getMany:async({resource:e,ids:t,meta:o})=>{let{headers:n,method:d}=o??{},i=d??"get",{data:c}=await s[i](`${r}/${e}?${y({id:t})}`,{headers:n});return{data:c}},create:async({resource:e,variables:t,meta:o})=>{let n=`${r}/${e}`,{headers:d,method:i}=o??{},c=i??"post",{data:a}=await s[c](n,t,{headers:d});return{data:a}},update:async({resource:e,id:t,variables:o,meta:n})=>{let d=`${r}/${e}/${t}`,{headers:i,method:c}=n??{},a=c??"patch",{data:p}=await s[a](d,o,{headers:i});return{data:p}},getOne:async({resource:e,id:t,meta:o})=>{let n=`${r}/${e}/${t}`,{headers:d,method:i}=o??{},c=i??"get",{data:a}=await s[c](n,{headers:d});return{data:a}},deleteOne:async({resource:e,id:t,variables:o,meta:n})=>{let d=`${r}/${e}/${t}`,{headers:i,method:c}=n??{},a=c??"delete",{data:p}=await s[a](d,{data:o,headers:i});return{data:p}},getApiUrl:()=>r,custom:async({url:e,method:t,filters:o,sorters:n,payload:d,query:i,headers:c})=>{let a=`${e}?`;if(n){let m=f(n);if(m){let{_sort:x,_order:v}=m,u={_sort:x.join(","),_order:v.join(",")};a=`${a}&${y(u)}`}}if(o){let m=g(o);a=`${a}&${y(m)}`}i&&(a=`${a}&${y(i)}`);let p;switch(t){case"put":case"post":case"patch":p=await s[t](e,d,{headers:c});break;case"delete":p=await s.delete(e,{data:d,headers:c});break;default:p=await s.get(a,{headers:c});break}let{data:$}=p;return Promise.resolve({data:$})}});var N=q;export{h as axiosInstance,N as default,g as generateFilter,f as generateSort,M as mapOperator,J as stringify};
//# sourceMappingURL=index.mjs.map